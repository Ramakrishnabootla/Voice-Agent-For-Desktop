## JARVIS-2.0 Mailing System Architecture

Here's a clear breakdown of how the mailing system logic is implemented and flows through the application:

### **Overall Architecture**

The mailing system follows a **hybrid voice-text input model** with **blocking execution** to ensure sequential processing. It integrates:

1. **Voice Recognition** (SpeechRecognition library)
2. **Web UI** (Flask + HTML/JS for text input)
3. **Email Service** (Gmail SMTP)
4. **Audio Feedback** (Text-to-speech)

### **Component Breakdown**

#### **1. Command Detection (`myAI.py` - Main Loop)**
```python
# In custom_responses dict:
"send email": "send_email",
"jarvis send email": "send_email"

# Main loop processing:
elif matched_response == "send_email":
    send_email()  # Currently threaded, but user reports efficient operation
```

**Logic**: When user says "send email", the main loop matches it against `custom_responses` and calls `send_email()`.

#### **2. Email Composition (`send_email()` function)**

**Step-by-Step Flow:**

1. **Credential Validation**
   ```python
   EMAIL = os.getenv("EMAIL")
   PASSWORD = os.getenv("EMAIL_APP_PASSWORD")
   ```
   - Pulls credentials from environment variables
   - Validates presence, exits if missing

2. **Receiver Email Input (Text-based)**
   ```python
   print_slow_and_speak("Please enter the receiver's email in the text box")
   # Polls for text_command.txt file
   while not receiver_email and time.time() - start_time < 30:
       if os.path.exists('text_command.txt'):
           # Reads and removes the file
   ```
   - Speaks prompt to user
   - Waits up to 30 seconds for web UI input
   - Uses file-based IPC (`text_command.txt`)

3. **Subject Input (Voice-based)**
   ```python
   subject = get_voice_input("Please say the subject")
   ```
   - Calls `get_voice_input()` which:
     - Speaks prompt
     - Records 5 seconds of audio
     - Transcribes using SpeechRecognition
     - Returns text or None

4. **Body Input (Voice-based)**
   ```python
   body = get_voice_input("Please say the body")
   ```
   - Same process as subject

5. **Email Construction**
   ```python
   msg = MIMEMultipart()
   msg['From'] = EMAIL
   msg['To'] = receiver_email
   msg['Subject'] = subject
   msg.attach(MIMEText(body, 'plain'))
   ```

6. **Email Sending**
   ```python
   server = smtplib.SMTP('smtp.gmail.com', 587)
   server.starttls()
   server.login(EMAIL, PASSWORD)
   server.sendmail(EMAIL, receiver_email, text)
   ```

#### **3. Web UI Integration (`app.py` + `templates/index.html`)**

**Flask Route:**
```python
@app.route("/text_command", methods=["POST"])
def text_command():
    data = request.get_json()
    command = data.get('command', '')
    if command:
        with open('text_command.txt', 'w') as f:
            f.write(command)
```

**HTML/JS:**
- User types email in text box
- JavaScript sends POST to `/text_command`
- Creates `text_command.txt` file

#### **4. Audio Processing Functions**

- **`record_audio()`**: Uses `sounddevice` to capture microphone input
- **`transcribe_audio_using_sr()`**: Converts audio to text using Google Speech Recognition
- **`get_voice_input()`**: Orchestrates voice capture and transcription
- **`print_slow_and_speak()`**: Provides audio feedback (non-blocking)

### **Data Flow Diagram**

```
User Voice: "send email"
    ↓
Main Loop (myAI.py)
    ↓
send_email() Function
    ├── Credential Check (env vars)
    ├── Receiver: Web UI → text_command.txt → File Read
    ├── Subject: Voice → record_audio() → transcribe_audio_using_sr()
    ├── Body: Voice → record_audio() → transcribe_audio_using_sr()
    ├── Construct MIMEMultipart Email
    └── Send via Gmail SMTP
```

### **Key Design Decisions**

1. **Blocking Execution**: Prevents parallel command processing during email composition
2. **Hybrid Input**: Text for receiver (precise), voice for content (convenient)
3. **File-based IPC**: Simple communication between Flask and AI processes
4. **Timeout Handling**: 30-second windows prevent indefinite waiting
5. **Fallback Values**: "No Subject"/"No Body" if voice fails
6. **Error Handling**: Comprehensive try/catch with user feedback


#env contents 

EMAIL=help.trendtalks@gmail.com
EMAIL_APP_PASSWORD=enxq ctkv krut lezq

### **Integration Points**

- **Flask Web Server**: Runs on port 7000, serves UI and handles text input
- **Environment Variables**: Secure credential storage
- **Threading**: Currently used for send_email (though user reports good performance)
- **Audio Libraries**: sounddevice (recording), SpeechRecognition (transcription), pygame (playback)

This architecture ensures reliable, user-friendly email composition with clear separation of concerns between voice/text input modalities and robust error handling throughout the process.